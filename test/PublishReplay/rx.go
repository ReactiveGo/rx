// Code generated by jig; DO NOT EDIT.

//go:generate jig --regen

package PublishReplay

import (
	"errors"
	"sync"
	"sync/atomic"
	"time"

	"github.com/reactivego/rx/schedulers"
	"github.com/reactivego/subscriber"
)

//jig:name Scheduler

// Scheduler is used to schedule tasks to support subscribing and observing.
type Scheduler interface {
	Schedule(task func())
}

//jig:name Subscriber

// Subscriber is an alias for the subscriber.Subscriber interface type.
type Subscriber subscriber.Subscriber

//jig:name IntObserveFunc

// IntObserveFunc is essentially the observer, a function that gets called
// whenever the observable has something to report.
type IntObserveFunc func(int, error, bool)

var zeroInt int

// Next is called by an ObservableInt to emit the next int value to the
// observer.
func (f IntObserveFunc) Next(next int) {
	f(next, nil, false)
}

// Error is called by an ObservableInt to report an error to the observer.
func (f IntObserveFunc) Error(err error) {
	f(zeroInt, err, true)
}

// Complete is called by an ObservableInt to signal that no more data is
// forthcoming to the observer.
func (f IntObserveFunc) Complete() {
	f(zeroInt, nil, true)
}

//jig:name ObservableInt

// ObservableInt is essentially a subscribe function taking an observe
// function, scheduler and an subscriber.
type ObservableInt func(IntObserveFunc, Scheduler, Subscriber)

//jig:name IntObserver

// IntObserver is the interface used with CreateInt when implementing a custom
// observable.
type IntObserver interface {
	// Next emits the next int value.
	Next(int)
	// Error signals an error condition.
	Error(error)
	// Complete signals that no more data is to be expected.
	Complete()
	// Closed returns true when the subscription has been canceled.
	Closed() bool
}

//jig:name CreateInt

// CreateInt creates an Observable from scratch by calling observer methods
// programmatically.
func CreateInt(f func(IntObserver)) ObservableInt {
	observable := func(observe IntObserveFunc, scheduler Scheduler, subscriber Subscriber) {
		scheduler.Schedule(func() {
			if subscriber.Closed() {
				return
			}
			observer := func(next int, err error, done bool) {
				if !subscriber.Closed() {
					observe(next, err, done)
				}
			}
			type observer_subscriber struct {
				IntObserveFunc
				Subscriber
			}
			f(&observer_subscriber{observer, subscriber})
		})
	}
	return observable
}

//jig:name FromChanInt

// FromChanInt creates an ObservableInt from a Go channel of int values.
// It's not possible for the code feeding into the channel to send an error.
// The feeding code can send zero or more int items and then closing the
// channel will be seen as completion.
func FromChanInt(ch <-chan int) ObservableInt {
	return CreateInt(func(observer IntObserver) {
		for next := range ch {
			if observer.Closed() {
				return
			}
			observer.Next(next)
		}
		observer.Complete()
	})
}

//jig:name NewScheduler

func NewGoroutine() Scheduler { return &schedulers.Goroutine{} }

func NewTrampoline() Scheduler { return &schedulers.Trampoline{} }

//jig:name SubscribeOptions

// Subscription is an alias for the subscriber.Subscription interface type.
type Subscription subscriber.Subscription

// SubscribeOptions is a struct with options for Subscribe related methods.
type SubscribeOptions struct {
	// SubscribeOn is the scheduler to run the observable subscription on.
	SubscribeOn Scheduler
	// OnSubscribe is called right after the subscription is created and before
	// subscribing continues further.
	OnSubscribe func(subscription Subscription)
	// OnUnsubscribe is called by the subscription to notify the client that the
	// subscription has been canceled.
	OnUnsubscribe func()
}

// NewSubscriber will return a newly created subscriber. Before returning the
// subscription the OnSubscribe callback (if set) will already have been called.
func (options SubscribeOptions) NewSubscriber() Subscriber {
	subscription := subscriber.NewWithCallback(options.OnUnsubscribe)
	if options.OnSubscribe != nil {
		options.OnSubscribe(subscription)
	}
	return subscription
}

// SubscribeOptionSetter is the type of a function for setting SubscribeOptions.
type SubscribeOptionSetter func(options *SubscribeOptions)

// SubscribeOn takes the scheduler to run the observable subscription on and
// additional setters. It will first set the SubscribeOn option before
// calling the other setters provided as a parameter.
func SubscribeOn(subscribeOn Scheduler, setters ...SubscribeOptionSetter) SubscribeOptionSetter {
	return func(options *SubscribeOptions) {
		options.SubscribeOn = subscribeOn
		for _, setter := range setters {
			setter(options)
		}
	}
}

// OnSubscribe takes a callback to be called on subscription.
func OnSubscribe(callback func(Subscription)) SubscribeOptionSetter {
	return func(options *SubscribeOptions) { options.OnSubscribe = callback }
}

// OnUnsubscribe takes a callback to be called on subscription cancelation.
func OnUnsubscribe(callback func()) SubscribeOptionSetter {
	return func(options *SubscribeOptions) { options.OnUnsubscribe = callback }
}

// NewSubscribeOptions will create a new SubscribeOptions struct and then call
// the setter on it to recursively set all the options. It then returns a
// pointer to the created SubscribeOptions struct.
func NewSubscribeOptions(setter SubscribeOptionSetter) *SubscribeOptions {
	options := &SubscribeOptions{}
	setter(options)
	return options
}

//jig:name ObservableIntSubscribe

// Subscribe operates upon the emissions and notifications from an Observable.
// This method returns a Subscriber.
func (o ObservableInt) Subscribe(observe IntObserveFunc, setters ...SubscribeOptionSetter) Subscriber {
	scheduler := NewTrampoline()
	setter := SubscribeOn(scheduler, setters...)
	options := NewSubscribeOptions(setter)
	subscriber := options.NewSubscriber()
	observer := func(next int, err error, done bool) {
		if !done {
			observe(next, err, done)
		} else {
			observe(zeroInt, err, true)
			subscriber.Unsubscribe()
		}
	}
	o(observer, options.SubscribeOn, subscriber)
	return subscriber
}

//jig:name ConnectableInt

// ConnectableInt is an ObservableInt that has an additional method Connect()
// used to Subscribe to the parent observable and then multicasting values to
// all subscribers of ConnectableInt.
type ConnectableInt struct {
	ObservableInt
	connect func(options []SubscribeOptionSetter) Subscription
}

//jig:name ObservableIntMulticast

// Multicast converts an ordinary Observable into a connectable Observable.
// A connectable observable will only start emitting values after its Connect
// method has been called. The factory method passed in should return a
// new SubjectInt that implements the actual multicasting behavior.
func (o ObservableInt) Multicast(factory func() SubjectInt) ConnectableInt {
	const (
		active int32 = iota
		notifying
		terminated
	)
	var subject struct {
		state int32
		atomic.Value
	}
	subject.Store(factory())
	observable := func(observe IntObserveFunc, subscribeOn Scheduler, subscriber Subscriber) {
		if s, ok := subject.Load().(SubjectInt); ok {
			println("subscribing......")
			s.ObservableInt(observe, subscribeOn, subscriber)
			println("done subscribing......")
		}
	}
	observer := func(next int, err error, done bool) {
		if atomic.CompareAndSwapInt32(&subject.state, active, notifying) {
			println("next")
			if s, ok := subject.Load().(SubjectInt); ok {
				s.IntObserveFunc(next, err, done)
			}
			if !done {
				atomic.CompareAndSwapInt32(&subject.state, notifying, active)
			} else {
				atomic.CompareAndSwapInt32(&subject.state, notifying, terminated)
			}
		}
	}
	const (
		unsubscribed int32 = iota
		subscribed
	)
	var subscriber struct {
		state int32
		atomic.Value
	}
	connect := func(options []SubscribeOptionSetter) Subscription {
		if atomic.CompareAndSwapInt32(&subject.state, terminated, active) {
			subject.Store(factory())
		}
		if atomic.CompareAndSwapInt32(&subscriber.state, unsubscribed, subscribed) {
			subscription := o.Subscribe(observer, options...)
			subscriber.Store(subscription)
			subscription.Add(func() {
				atomic.CompareAndSwapInt32(&subscriber.state, subscribed, unsubscribed)
			})
		}
		subscription := subscriber.Load().(Subscriber)
		return subscription.Add(func() { subscription.Unsubscribe() })
	}
	return ConnectableInt{ObservableInt: observable, connect: connect}
}

//jig:name SubjectInt

// SubjectInt is a combination of an observer and observable. Subjects are
// special because they are the only reactive constructs that support
// multicasting. The items sent to it through its observer side are
// multicasted to multiple clients subscribed to its observable side.
//
// A SubjectInt embeds ObservableInt and IntObserveFunc. This exposes the
// methods and fields of both types on SubjectInt. Use the ObservableInt
// methods to subscribe to it. Use the IntObserveFunc Next, Error and Complete
// methods to feed data to it.
//
// After a subject has been terminated by calling either Error or Complete,
// it goes into terminated state. All subsequent calls to its observer side
// will be silently ignored. All subsequent subscriptions to the observable
// side will be handled according to the specific behavior of the subject.
// There are different types of subjects, see the different NewXxxSubjectInt
// functions for more info.
//
// Important! a subject is a hot observable. This means that subscribing to
// it will block the calling goroutine while it is waiting for items and
// notifications to receive. Unless you have code on a different goroutine
// already feeding into the subject, your subscribe will deadlock.
// Alternatively, you could subscribe on a goroutine as shown in the example.
type SubjectInt struct {
	ObservableInt
	IntObserveFunc
}

//jig:name NewBufChan

// BufChan is a fixed capacity buffer non-blocking channel where entries
// are appended in a circular fashion. Use Send to append entries to the channel
// buffer, use NewEndpoint to create an endpoint to receive from the channel.
// If the channel buffer is full (contains bufferCapacity items) then the next
// call to Send will overwrite the first entry in the channel buffer.
//
// The actual channel buffer capacity is 1 entry larger than the bufferCapacity
// passed to NewBufChan. A full channel has the write position for the
// next entry immediately adjoining the read postion of the first entry in the
// channel buffer. This means that even in a full channel buffer, there is a
// single emtpy slot at the write position. This single empty slot is used to
// store a "tombstone" when the channel is closed and thus will not be updated
// further. To close the channel, call the Close method with nil or error.
type BufChan struct {
	sync.RWMutex
	cond     *sync.Cond
	channel  []bufChanMessage
	read     int64
	write    int64
	size     int64
	duration time.Duration
}

// NewBufChan returns a non-blocking BufChan with given buffer capacity and time
// window. The window specifies how long items send to the channel will remain
// fresh. After sent values become stale they are no longer returned when the
// channel buffer is iterated with an endpoint.
//
// A bufferCapacity of 0 will result in a channel that cannot send data, but
// that can signal that it has been closed. A windowDuration of 0 will make the
// sent values remain fresh forever.
func NewBufChan(bufferCapacity int, windowDuration time.Duration) *BufChan {
	b := &BufChan{
		channel:  make([]bufChanMessage, bufferCapacity+1),
		size:     int64(bufferCapacity + 1),
		duration: windowDuration,
	}
	b.cond = sync.NewCond(b)
	return b
}

// Send will append the value at the end of the channel buffer. If the channel
// buffer is full, the first entry in the channel buffer is overwritten and the
// channel buffer start moved to the second entry. If the channel was closed
// previously by calling Close, this call to Send is ignored.
func (b *BufChan) Send(value interface{}) {
	b.Lock()
	defer b.Unlock()
	if b.channel[b.write%b.size].value != nil {
		return
	}
	var staleAfter time.Time
	if b.duration != 0 {
		staleAfter = time.Now().Add(b.duration)
	}
	b.channel[b.write%b.size] = bufChanMessage{value, staleAfter}
	b.write++
	if b.write-b.read == b.size {
		b.read++
		b.channel[b.write%b.size] = bufChanMessage{}
	}
	b.cond.Broadcast()
}

// Close will mark the channel as closed. Pass either an error value to indicate
// an error, or nil to indicate normal completion. Once the channel has been
// closed, all calls to Send will return immediately without modifying the
// channel buffer.
func (b *BufChan) Close(err error) {
	b.Lock()
	defer b.Unlock()
	if err != nil {
		b.channel[b.write%b.size] = bufChanMessage{value: err}
	} else {
		b.channel[b.write%b.size] = bufChanMessage{value: "completion"}
	}
	b.cond.Broadcast()
}

// NewEndpoint will return a receive endpoint that can be used to receive from
// the channel. A new endpoint may also be created for a closed channel, even
// if it was closed with an error. The buffered content of a closed channel can
// be received normally.
func (b *BufChan) NewEndpoint() *BufEndpoint {
	b.RLock()
	defer b.RUnlock()
	return &BufEndpoint{b, b.read, false}
}

// BufEndpoint is a receive endpoint used for receiving from a channel buffer. A
// newly created endpoint will start reading at the start of the channel buffer
// at the moment NewEndpoint was called. Reading from the endpoint using Recv
// calls will continue until the end of the channel buffer is reached.
//
// The channel buffer may grow while it is being iterated, the endpoint will
// reflect that. The channel may grow too fast for an endpoint to be able to
// keep up. This causes the end of the channel buffer to overflow the endpoint
// current position. At that point the endpoint will have effectively dropped
// all data. If that happens, the endpoint will fail and emit an
// ErrMissingBackpressure error. Sibling endpoints are not affected by this, nor
// is the channel itself.
type BufEndpoint struct {
	*BufChan
	cursor   int64
	overflow bool
}

// ErrMissingBackpressure is delivered to an endpoint when the channel overflows
// because the endpoint can't keep-up with the data rate at which the sender
// sends values. Other sibling endpoints that are fast enough won't get this
// error and continue to operate normally.
var ErrMissingBackpressure = errors.New("missing backpressure")

// Recv will return the next value in the channel and true. Or when at the end
// of the channel buffer nil and false. The channel buffer can still be
// iterated after it is finalized by calling Close. If the endpoint could not
// keep up with the sender, then it returns nil and false. Closed will in that
// case report ErrMissingBackpressure.
func (ep *BufEndpoint) Recv() (interface{}, bool) {
	ep.RLock()
	defer ep.RUnlock()
	now := time.Now()
	if ep.cursor < ep.read {
		ep.overflow = true
	}
	if ep.overflow {
		return nil, false
	}
	for ep.cursor != ep.write {
		entry := ep.channel[ep.cursor%ep.size]
		ep.cursor++
		if entry.stale.IsZero() || entry.stale.After(now) {
			return entry.value, true
		}
	}
	return nil, false
}

// Closed returns true once the channel buffer has been finalized by calling
// Close on the channel. The returned error either has a value (the error) or
// is nil (to indicate completion). Note, that this call is independent of how
// far the endpoint has currently iterated the channel buffer.
//
// The error ErrMissingBackpressure will be delivered if the endpoint does not
// receive data fast enough to keep up with the sender.
func (ep *BufEndpoint) Closed() (error, bool) {
	ep.RLock()
	defer ep.RUnlock()
	if ep.overflow {
		return ErrMissingBackpressure, true
	}
	entry := ep.channel[ep.write%ep.size]
	if entry.value != nil {
		if err, ok := entry.value.(error); ok {
			return err, true
		} else {
			return nil, true
		}
	}
	return nil, false
}

// Wait will wait for a Send or Close call on the channel by the sender.
func (ep *BufEndpoint) Wait() {
	ep.Lock()
	defer ep.Unlock()
	if ep.overflow {
		return
	}
	if ep.cursor != ep.write {
		return
	}
	if ep.channel[ep.write%ep.size].value != nil {
		return
	}
	ep.cond.Wait()
}

// Range will call the function for every received value and will call the
// function one final time when the channel is closed.
func (ep *BufEndpoint) Range(f func(interface{}, error, bool) bool) {
	for more := true; more; {
		if next, ok := ep.Recv(); ok {
			more = f(next, nil, false)
		} else {
			if err, ok := ep.Closed(); ok {
				f(nil, err, true)
				return
			} else {
				ep.Wait()
			}
		}
	}
}

// bufChanMessage instances store the values in a BufChan. It also
// contains a timestamp indicating when it will become stale. You will never
// need to deal with bufChanMessage instances directly.
type bufChanMessage struct {
	value interface{}
	stale time.Time
}

//jig:name MaxReplayCapacity

// MaxReplayCapacity is the maximum size of a replay buffer. Can be modified.
var MaxReplayCapacity = 16383

//jig:name ErrTypecastToInt

// ErrTypecastToInt is delivered to an observer if the generic value cannot be
// typecast to int.
var ErrTypecastToInt = errors.New("typecast to int failed")

//jig:name NewReplaySubjectInt

// NewReplaySubjectInt creates a new ReplaySubject. ReplaySubject ensures that
// all observers see the same sequence of emitted items, even if they
// subscribe after. When bufferCapacity argument is 0, then MaxReplayCapacity is
// used (currently 16383). When windowDuration argument is 0, then entries added
// to the buffer will remain fresh forever.
//
// Note that this implementation is non-blocking. When no subscribers are
// present the buffer fills up to bufferCapacity after which new items will
// start overwriting the oldest ones according to the FIFO principle.
// If a subscriber cannot keep up with the data rate of the source observable,
// eventually the buffer for the subscriber will overflow. At that moment the
// subscriber will receive an ErrMissingBackpressure error.
func NewReplaySubjectInt(bufferCapacity int, windowDuration time.Duration) SubjectInt {
	if bufferCapacity == 0 {
		bufferCapacity = MaxReplayCapacity
	}
	channel := NewBufChan(bufferCapacity, windowDuration)

	observable := Create(func(observer Observer) {
		channel.NewEndpoint().Range(func(value interface{}, err error, closed bool) bool {
			println("enumerating....")
			if observer.Closed() {
				return false
			}
			switch {
			case !closed:
				observer.Next(value)
			case err != nil:
				observer.Error(err)
			default:
				observer.Complete()
			}
			return !observer.Closed()
		})
	})

	observer := func(next int, err error, done bool) {
		if !done {
			channel.Send(next)
		} else {
			channel.Close(err)
		}
	}

	return SubjectInt{observable.AsInt(), observer}
}

//jig:name ObservableIntReplay

// Replay uses Multicast to control the subscription of a ReplaySubject to a
// source observable and turns the subject into a connectable observable.
// A ReplaySubject emits to any observer all of the items that were emitted by
// the source observable, regardless of when the observer subscribes.
//
// If the source completed and as a result the internal ReplaySubject
// terminated, then calling Connect again will replace the old ReplaySubject
// with a newly created one.
func (o ObservableInt) Replay(bufferCapacity int, windowDuration time.Duration) ConnectableInt {
	factory := func() SubjectInt {
		return NewReplaySubjectInt(bufferCapacity, windowDuration)
	}
	return o.Multicast(factory)
}

//jig:name ObservableIntWait

// Wait subscribes to the Observable and waits for completion or error.
// Returns either the error or nil when the Observable completed normally.
func (o ObservableInt) Wait(setters ...SubscribeOptionSetter) (e error) {
	o.Subscribe(func(next int, err error, done bool) {
		if done {
			e = err
		}
	}, setters...).Wait()
	return e
}

//jig:name ObserveFunc

// ObserveFunc is essentially the observer, a function that gets called
// whenever the observable has something to report.
type ObserveFunc func(interface{}, error, bool)

var zero interface{}

// Next is called by an Observable to emit the next interface{} value to the
// observer.
func (f ObserveFunc) Next(next interface{}) {
	f(next, nil, false)
}

// Error is called by an Observable to report an error to the observer.
func (f ObserveFunc) Error(err error) {
	f(zero, err, true)
}

// Complete is called by an Observable to signal that no more data is
// forthcoming to the observer.
func (f ObserveFunc) Complete() {
	f(zero, nil, true)
}

//jig:name Observable

// Observable is essentially a subscribe function taking an observe
// function, scheduler and an subscriber.
type Observable func(ObserveFunc, Scheduler, Subscriber)

//jig:name Observer

// Observer is the interface used with Create when implementing a custom
// observable.
type Observer interface {
	// Next emits the next interface{} value.
	Next(interface{})
	// Error signals an error condition.
	Error(error)
	// Complete signals that no more data is to be expected.
	Complete()
	// Closed returns true when the subscription has been canceled.
	Closed() bool
}

//jig:name Create

// Create creates an Observable from scratch by calling observer methods
// programmatically.
func Create(f func(Observer)) Observable {
	observable := func(observe ObserveFunc, scheduler Scheduler, subscriber Subscriber) {
		scheduler.Schedule(func() {
			if subscriber.Closed() {
				return
			}
			observer := func(next interface{}, err error, done bool) {
				if !subscriber.Closed() {
					observe(next, err, done)
				}
			}
			type observer_subscriber struct {
				ObserveFunc
				Subscriber
			}
			f(&observer_subscriber{observer, subscriber})
		})
	}
	return observable
}

//jig:name ConnectableIntConnect

// Connect instructs a connectable Observable to begin emitting items to its
// subscribers. All values will then be passed on to the observers that
// subscribed to this connectable observable
func (c ConnectableInt) Connect(options ...SubscribeOptionSetter) Subscription {
	return c.connect(options)
}

//jig:name ObservableIntToSlice

// ToSlice collects all values from the ObservableInt into an slice. The
// complete slice and any error are returned.
//
// This function subscribes to the source observable on the Goroutine scheduler.
// The Goroutine scheduler works in more situations for complex chains of
// observables, like when merging the output of multiple observables.
func (o ObservableInt) ToSlice(setters ...SubscribeOptionSetter) (a []int, e error) {
	scheduler := NewGoroutine()
	o.Subscribe(func(next int, err error, done bool) {
		if !done {
			a = append(a, next)
		} else {
			e = err
		}
	}, SubscribeOn(scheduler, setters...)).Wait()
	return a, e
}

//jig:name ConnectableIntAutoConnect

// AutoConnect makes a ConnectableInt behave like an ordinary ObservableInt that
// automatically connects when the specified number of clients subscribe to it.
// If count is 0, then AutoConnect will immediately call connect on the
// ConnectableInt before returning the ObservableInt part of the ConnectableInt.
func (o ConnectableInt) AutoConnect(count int, options ...SubscribeOptionSetter) ObservableInt {
	if count == 0 {
		o.connect(options)
		return o.ObservableInt
	}
	var refcount int32
	observable := func(observe IntObserveFunc, subscribeOn Scheduler, subscriber Subscriber) {
		if atomic.AddInt32(&refcount, 1) == int32(count) {
			println("connecting")
			o.connect(options)
			println("connected")
		}
		o.ObservableInt(observe, subscribeOn, subscriber)
	}
	return observable
}

//jig:name ObservableAsInt

// AsInt turns an Observable of interface{} into an ObservableInt. If during
// observing a typecast fails, the error ErrTypecastToInt will be emitted.
func (o Observable) AsInt() ObservableInt {
	observable := func(observe IntObserveFunc, subscribeOn Scheduler, subscriber Subscriber) {
		observer := func(next interface{}, err error, done bool) {
			if !done {
				if nextInt, ok := next.(int); ok {
					observe(nextInt, err, done)
				} else {
					observe(zeroInt, ErrTypecastToInt, true)
				}
			} else {
				observe(zeroInt, err, true)
			}
		}
		o(observer, subscribeOn, subscriber)
	}
	return observable
}
