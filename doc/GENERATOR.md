
I'm trying to create a generator to automatically implement functions when they are used in
a program. 

So if I type:

```
a := FromInts(1,2,3,4,5).Last().ToOne()
fmt.Println(a)

//Output:
// 5
```

When this is compiled the FromInts will not be initially found.
We'll get an error:

```
./main.go:4: undefined: FromInts
```

What I expect is that FromInts will be matched to From<T>s declaration:

```
func From<T>s(array ...<t>) Observable<T>
```


and that <T> is
determined to be Int and therefore <t> is int. Now the code for this should be
generated by expanding the code associated with the From<T>s declaration.
From<T>s depends on Observable<T> which depends on <T>Observer and I expect
that ObservableInt amd IntObserver are generated also.
Because From<T>s depends on From<T>Array which itself depends on Create<T> these
will be generated also.

So after the first round of code generation the FromInts() function will be valid.
A second compilation will now fail on Last().

```
./main.go:4: FromInts(1, 2, 3, 4, 5).Last undefined (type ObservableInt has no field or method Last)
```

So the compiler tells us that ObservableInt has no field or method Last. We can do something about
that as Last is declared as:

```
<*> func (o Observable<T>) Last() Observable<T>
```

This declaration literally means Observable<T> has method or field Last so we should just generate
Last and everything it depends on.

This also will work in the same way for ToOne().

```
./main.go:4: FromInts(1, 2, 3, 4, 5).Last().ToOne undefined (type ObservableInt has no field or method ToOne)
```


This is code that can be used to match regular expressions:

```
package main

import (
	"fmt"
	"regexp"
)

func main() {
	re := regexp.MustCompile("^From(.*)s$")
	fmt.Printf("%q\n", re.FindStringSubmatch("FromFloat64s"))
}
```


These are the errors that are reported by the compiler
1. "./main.go:4: undefined: FromInts"
2. "./main.go:4: FromInts(1, 2, 3, 4, 5).Last undefined (type ObservableInt has no field or method Last)"
3. "./main.go:4: FromInts(1, 2, 3, 4, 5).Last().MapFloat64 undefined (type ObservableInt has no field or method MapFloat64)"
4. "./main.go:6: FromInts(1, 2, 3, 4, 5).Last().MapFloat64(func literal).ToOne undefined (type ObservableFloat64 has no field or method ToOne)"

The following regular expressions will match these error strings and report correct submatches
1. "undefined: (.*)$"
2,3,4 "undefined [(]type (.*) has no field or method (.*)[)]$"

We can join the reported submatches together so we get a single error string
1. FromInts
2. ObservableInt,Last
3. ObservableInt,MapFloat64			
4. ObservableFloat64,ToOne

We match the condenced error string with the regular expressions representing our code snippets.

"^From(.*)s$"					func From<T>s(array ...<t>) Observable<T>
"^Observable(.*),Last$"			func (o Observable<T>) Last() Observable<T>
"^Observable(.*),Map(.*)$"		func (o Observable<T>) Map<U>(f func(<t>) <u>) Observable<U>
"^Observable(.*),ToOne$"		func (o Observable<T>) ToOne() <t>

It is easy to see that we can transform the declarations into golang template expansions. using {{.T}} instead of <T> etc.


