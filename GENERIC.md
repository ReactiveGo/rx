# Generics Library

In order to use the package as a generic programming library, first install the [*jig*](https://github.com/reactivego/jig) tool.
It generates source code from a generics library. 

Using the library is very simple. Just import the library with the blank identifier `_`.

```go
import _ "github.com/reactivego/rx"
```
The use of `_` stops the *go* tool from complaining about you not using any code from the package while at the same time allowing the [*jig*](https://github.com/reactivego/jig) tool to actually find the generics in the library.

Then you write a program as follows:

```go	
package main

import _ "github.com/reactivego/rx"

func main() {
  JustString("Hello, World!").Println()
  // Output: Hello, World!
}
```
This will not build currently, because `JustString` doesn't exists yet. Follow the following steps:

1. You write a program that references templates from the `rx` library, as was shown above.
2. You run the [jig](https://github.com/reactivego/jig) command in the directory where your program source is located.
3. **Now [jig](https://github.com/reactivego/jig) analyzes your source code and determines what additional code is needed to make it build**.
4. *[jig](https://github.com/reactivego/jig)* takes templates from the `rx` library and specializes them on specific types.
5. Specializations are generated into the file `rx.go` alongside your own code.
6. If all went well, your code will now build.

This was a bird's-eye view of the whole process. In the rest of this document we'll go through all the steps in more detail. Starting from the beginning:

## Preparing the Working Directory
Let's create a new folder for our simple program and start editing the file `main.go`.

```bash
$ mkdir -p ~/go/hellorx
$ cd ~/go/hellorx
$ go mod init hellorx
go: creating new go.mod: module hellorx
$ subl main.go
```
> We use *Sublime Text* for code editing, hence the use of the `subl` command.

## Writing the Program
Now that you have your `main.go` file open (in the editor of your choice), enter the following code:

```go
package main

import _ "github.com/reactivego/rx"

func main() {
	FromString("You!", "Gophers!", "World!").
		MapString(func(x string) string {
			return "Hello, " + x
		}).
		Println()
}
```
Running the program from the command-line will fail:
```bash
$ go run *.go
# command-line-arguments
./main.go:6:2: undefined: FromString
```

## Generating Code
Go to the command-line now and run the [jig](https://github.com/reactivego/jig) tool.
Use the verbose flag `-v` to see what [jig](https://github.com/reactivego/jig) is doing:
```bash
$ jig -v
found 133 templates in package "rx" (github.com/reactivego/rx/generic)
found 16 templates in package "multicast" (github.com/reactivego/multicast/generic)
generating "FromString"
  Scheduler
  Subscriber
  StringObserver
  ObservableString
  FromString
generating "ObservableString MapString"
  ObservableString MapString
generating "ObservableString Println"
  ObservableString Println
writing file "rx.go"
```
> The file **rx.go** was generated

## Running the Program
Now we can try to run the code and see what it does.

```bash
$ go run main.go rx.go
Hello, You!
Hello, Gophers!
Hello, World!
```
> Success! 

Code was generated into the file *rx.go* and we were able to run the program.
The idea behind [jig](https://github.com/reactivego/jig) (Just In-time Generics) has been to generate the minimal ammount of code needed to make a program run.
Turns out the generated file *rx.go* contains only around 70 lines of code:

```go
// Code generated by jig; DO NOT EDIT.

//go:generate jig

package main

import (
  "fmt"

  "github.com/reactivego/scheduler"
  "github.com/reactivego/subscriber"
)

type Scheduler = scheduler.Scheduler
type Subscriber = subscriber.Subscriber

type StringObserver func(next string, err error, done bool)
type ObservableString func(StringObserver, Scheduler, Subscriber)

func FromString(slice ...string) ObservableString {
  var zeroString string
  observable := func(observe StringObserver, scheduler Scheduler, subscriber Subscriber) {
    i := 0
    runner := scheduler.ScheduleRecursive(func(self func()) {
      if subscriber.Subscribed() {
        if i < len(slice) {
          observe(slice[i], nil, false)
          if subscriber.Subscribed() {
            i++
            self()
          }
        } else {
          observe(zeroString, nil, true)
        }
      }
    })
    subscriber.OnUnsubscribe(runner.Cancel)
  }
  return observable
}

func (o ObservableString) MapString(project func(string) string) ObservableString {
  observable := func(observe StringObserver, subscribeOn Scheduler, subscriber Subscriber) {
    observer := func(next string, err error, done bool) {
      var mapped string
      if !done {
        mapped = project(next)
      }
      observe(mapped, err, done)
    }
    o(observer, subscribeOn, subscriber)
  }
  return observable
}

func (o ObservableString) Println(a ...interface{}) (err error) {
  subscriber := subscriber.New()
  scheduler := scheduler.MakeTrampoline()
  observer := func(next string, e error, done bool) {
    if !done {
      fmt.Println(append(a, next)...)
    } else {
      err = e
      subscriber.Unsubscribe()
    }
  }
  subscriber.OnWait(scheduler.Wait)
  o(observer, scheduler, subscriber)
  subscriber.Wait()
  return
}
```
If you add additional code to the program that uses different generics of the `rx` library, then you should run `jig` again to generate specializations of those generics.
