# rx

    import _ "github.com/reactivego/rx/generic"

[![](https://godoc.org/github.com/reactivego/rx?status.png)](http://godoc.org/github.com/reactivego/rx/generic)

Package `rx` offers [Reactive eXtensions](http://reactivex.io/) for [Go](https://golang.org/). It's a generics library for composing asynchronous and event-based programs using observable sequences. The library consists of more than a 100 templates to enable type-safe programming with observable streams. To use it, you will need the *jig* tool from [Generics for Go](https://github.com/reactivego/generics).

Using the library is very simple. Import the library with the blank identifier `_` as the package name. The side effect of this import is that generics from the library can now be accessed by the *jig* tool.

Note, although the path to the generic package is `rx/generic` the actual package name is not `generic` but `rx`. Code generated by *jig* is written to the file `rx.go` by default. 

Write code that uses generics from the library and run *jig* to generate code.
The following is a minimal *Hello, World!* program:

```go
package main

import _ "github.com/reactivego/rx/generic"

func main() {
	FromStrings("You!", "Gophers!", "World!").
		MapString(func(x string) string {
			return "Hello, " + x
		}).Println()

	// Output:
	// Hello, You!
	// Hello, Gophers!
	// Hello, World!
}
```

## Generic Programming

Generics allow you to write code in terms of a placeholder type. To subsequently use the generic, you supply a specific type. Code then gets instantiated for that specific type with proper static type checking in place.

For example, `Map<T>` uses place-holder `T`. Go does not natively support this syntax. Instead we write`MapT`. Which is valid Go code. Now, how do we tell Go that `MapT` actually means `Map<T>`? For that we use a comment prefix e.g. `//jig:template Map<T>`.

See the example below for what a generic will look like when written this way:

```go
//jig:template Observable<Foo> Map<Bar>

func (o ObservableFoo) MapBar(project func(foo) bar) ObservableBar {
	...
	// generic implementation using `foo` and `bar` for the real type and `Foo` and `Bar` in identifiers
	...
}
```
I have choosen to use metasyntactic type names like *Foo* and *Bar* for my template libraries. So e.g. `MapBar` instead of `Map<T>`. I settled on using the words *Foo*, *Bar* and *Baz*, but you can choose other words you like better.

Using generics is easy. Just reference the generic in your code and specify a concrete type instead of the place-holder type.
So, to specialize on `int` write e.g. `MapInt`. See the following code for how that works: 

```go
FromInts(1, 2).MapInt(func(x int) int {
	return x + 10
}).Println()

// Output:
// 11
// 12
```
This code will not compile by itself, because MapInt is not known. Running the [jig](https://github.com/reactivego/generics/tree/master/cmd/jig) command will specialize all generic templates into compilable code.
