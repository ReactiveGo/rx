// NOTE: This file was generated by rxgo. Do not modify.

// Package {{.Package}} implements ReactiveX extensions for Go.
package {{.Package}}

//go:generate {{.Generate|Join}}

import (
	"errors"
	"rxgo/filters"
	"rxgo/schedulers"
	"rxgo/unsubscriber"
	"sync"
	"time"
{{- range .Imports}}
	"{{.}}"
{{- end}}
)

// ErrTimeout is delivered to an observer if the stream times out.
var ErrTimeout = errors.New("timeout")

// MaxReplaySize is the maximum size of a replay buffer. Can be modified.
var MaxReplaySize = {{.MaxReplaySize}}

type Scheduler schedulers.Scheduler

type Unsubscriber unsubscriber.Unsubscriber

// Subscribable is a struct returned as a result of calling
// the observable function. See e.g. type ObservableInt.
type Subscribable struct {
	SubscribeOn func(scheduler Scheduler)
	Unsubscriber
}

{{range $type := .Types -}}
{{$name := $type|TypeName -}}
////////////////////////////////////////////////////////
// {{$name}}Observer
////////////////////////////////////////////////////////

type {{$name}}Observer interface {
	Next({{$type}})
	Error(error)
	Complete()
	Unsubscribed() bool
}

type {{$name}}ObserverFunc func({{$type}}, error, bool)

var zero{{$name}} {{$type}}

func (f {{$name}}ObserverFunc) Next(next {{$type}}) {
	f(next, nil, false)
}

func (f {{$name}}ObserverFunc) Error(err error) {
	f(zero{{$name}}, err, false)
}

func (f {{$name}}ObserverFunc) Complete() {
	f(zero{{$name}}, nil, true)
}

////////////////////////////////////////////////////////
// Observable{{$name}}
////////////////////////////////////////////////////////

// Every observable is essentially a function taking
// an Observer (function) and returning a Subscribable.
type Observable{{$name}} func({{$name}}ObserverFunc) Subscribable

/////////////////////////////////////////////////////////////////////////////
// FROM
/////////////////////////////////////////////////////////////////////////////

// Create{{$name}} calls f(observer) to produce values for a stream of ints.
func Create{{$name}}(f func({{$name}}Observer)) Observable{{$name}} {
	observable := func(observer {{$name}}ObserverFunc) Subscribable {
		unsubscriber := new(unsubscriber.Int32)

		operation := func(next {{$type}}, err error, completed bool) {
			if !unsubscriber.Unsubscribed() {
				observer(next, err, completed)
			}
		}

		subscribeOn := func(scheduler Scheduler) {
			scheduler.Schedule(func() {
				if !unsubscriber.Unsubscribed() {
					defer unsubscriber.Unsubscribe()
					observer := &struct {
						{{$name}}ObserverFunc
						Unsubscriber
					}{operation, unsubscriber}
					f(observer)
				}
			})
		}

		return Subscribable{subscribeOn, unsubscriber}
	}
	return observable
}

func Empty{{$name}}() Observable{{$name}} {
	return Create{{$name}}(func(observer {{$name}}Observer) {
		observer.Complete()
	})
}

func Never{{$name}}() Observable{{$name}} {
	return Create{{$name}}(func(observer {{$name}}Observer) {
	})
}

func Throw{{$name}}(err error) Observable{{$name}} {
	return Create{{$name}}(func(observer {{$name}}Observer) {
		observer.Error(err)
	})
}

func From{{$name}}Array(array []{{$type}}) Observable{{$name}} {
	return Create{{$name}}(func(observer {{$name}}Observer) {
		for _, next := range array {
			if observer.Unsubscribed() {
				return
			}
			observer.Next(next)
		}
		observer.Complete()
	})
}

func From{{$name}}s(array ...{{$type}}) Observable{{$name}} {
	return From{{$name}}Array(array)
}

func From{{$name}}Channel(ch <-chan {{$type}}) Observable{{$name}} {
	return Create{{$name}}(func(observer {{$name}}Observer) {
		for next := range ch {
			if observer.Unsubscribed() {
				return
			}
			observer.Next(next)
		}
		observer.Complete()
	})
}

{{if eq $type "int" -}}
func Interval(interval time.Duration) Observable{{$name}} {
	return Create{{$name}}(func(observer {{$name}}Observer) {
		i := 0
		for {
			time.Sleep(interval)
			if observer.Unsubscribed() {
				return
			}
			observer.Next(i)
			i++
		}
	})
}

{{end -}}

func Just{{$name}}(element {{$type}}) Observable{{$name}} {
	return Create{{$name}}(func(observer {{$name}}Observer) {
		observer.Next(element)
		observer.Complete()
	})
}

{{if eq $type "int" -}}
func Range(start, count int) Observable{{$name}} {
	end := start + count
	return Create{{$name}}(func(observer {{$name}}Observer) {
		for i := start; i < end; i++ {
			if observer.Unsubscribed() {
				return
			}
			observer.Next(i)
		}
		observer.Complete()
	})
}

{{end -}}

// Repeat value count times.
func Repeat{{$name}}(value {{$type}}, count int) Observable{{$name}} {
	return Create{{$name}}(func(observer {{$name}}Observer) {
		for i := 0; i < count; i++ {
			if observer.Unsubscribed() {
				return
			}
			observer.Next(value)
		}
		observer.Complete()
	})
}

// Start{{$name}} is designed to be used with functions that return a
// ({{$type}}, error) tuple.
//
// If the error is non-nil the returned Observable{{$name}} will be that error,
// otherwise it will be a single-value stream of {{$type}}.
func Start{{$name}}(f func() ({{$type}}, error)) Observable{{$name}} {
	return Create{{$name}}(func(observer {{$name}}Observer) {
		if next, err := f(); err != nil {
			observer.Error(err)
		} else {
			observer.Next(next)
			observer.Complete()
		}
	})
}

func Merge{{$name}}(observables ...Observable{{$name}}) Observable{{$name}} {
	if len(observables) == 0 {
		return Empty{{$name}}()
	}
	return observables[0].Merge(observables[1:]...)
}

func Merge{{$name}}DelayError(observables ...Observable{{$name}}) Observable{{$name}} {
	if len(observables) == 0 {
		return Empty{{$name}}()
	}
	return observables[0].MergeDelayError(observables[1:]...)
}

/////////////////////////////////////////////////////////////////////////////
// Subscribe
/////////////////////////////////////////////////////////////////////////////

func (o Observable{{$name}}) SubscribeOn(scheduler Scheduler) Observable{{$name}} {
	observable := func(observer {{$name}}ObserverFunc) Subscribable {
		subscribable := o(observer)
		subscribable.SubscribeOn(scheduler)
		subscribable.SubscribeOn = func(scheduler Scheduler) { /* ignore */ }
		return subscribable
	}
	return observable
}

func (o Observable{{$name}}) Subscribe(observer {{$name}}ObserverFunc) Unsubscriber {
	subscribable := o(observer)
	subscribable.SubscribeOn(schedulers.GoroutineScheduler)
	return subscribable.Unsubscriber
}

func (o Observable{{$name}}) SubscribeNext(f func(v {{$type}})) Unsubscriber {
	operator := func(next {{$type}}, err error, completed bool) {
		if err == nil && !completed {
			f(next)
		}
	}
	return o.Subscribe(operator)
}

// Wait for completion of the stream and return any error.
func (o Observable{{$name}}) Wait() error {
	doneChan := make(chan error)
	operator := func(next {{$type}}, err error, completed bool) {
		if err != nil || completed {
			doneChan <- err
		}
	}
	o.Subscribe(operator)
	return <-doneChan
}

/////////////////////////////////////////////////////////////////////////////
// TO
/////////////////////////////////////////////////////////////////////////////

// ToOneWithError blocks until the stream emits exactly one value. Otherwise, it errors.
func (o Observable{{$name}}) ToOneWithError() (v {{$type}}, e error) {
	v = zero{{$name}}
	errch := make(chan error, 1)
	o.One().Subscribe(func(next {{$type}}, err error, completed bool) {
		if err != nil || completed {
			errch <- err
			// Close errch to make subsequent use of it panic. This will prevent
			// a coroutine inside an observable getting stuck on errch and leaking.
			close(errch)
		} else {
			v = next
		}
	})
	e = <-errch
	return
}

// ToOne blocks and returns the only value emitted by the stream, or the zero
// value if an error occurs.
func (o Observable{{$name}}) ToOne() {{$type}} {
	value, _ := o.ToOneWithError()
	return value
}

// ToArrayWithError collects all values from the stream into an array,
// returning it and any error.
func (o Observable{{$name}}) ToArrayWithError() (a []{{$type}}, e error) {
	a = []{{$type}}{}
	errch := make(chan error, 1)
	o.Subscribe(func(next {{$type}}, err error, completed bool) {
		if err != nil || completed {
			errch <- err
			// Close errch to make subsequent use of it panic. This will prevent
			// a coroutine inside an observable getting stuck on errch and leaking.
			close(errch)
		} else {
			a = append(a, next)
		}
	})
	e = <-errch
	return
}

// ToArray blocks and returns the values from the stream in an array.
func (o Observable{{$name}}) ToArray() []{{$type}} {
	out, _ := o.ToArrayWithError()
	return out
}

// ToChannelWithError returns next and error channels corresponding to the stream elements and
// any error. When the next channel closes, it may be either because of an error or
// because the observable completed. The next channel may be closed without having emitted any
// values. The error channel always emits a value to indicate the observable has finished.
// When the error channel emits nil then the observable completed without errors, otherwise
// the error channel emits the error. When the observable has finished both channels will be
// closed.
func (o Observable{{$name}}) ToChannelWithError() (<-chan {{$type}}, <-chan error) {
	nextch := make(chan {{$type}}, 1)
	errch := make(chan error, 1)
	o.Subscribe(func(next {{$type}}, err error, completed bool) {
		if err != nil || completed {
			errch <- err
			close(errch)
			close(nextch)
		} else {
			nextch <- next
		}
	})
	return nextch, errch
}

func (o Observable{{$name}}) ToChannel() <-chan {{$type}} {
	ch, _ := o.ToChannelWithError()
	return ch
}

/////////////////////////////////////////////////////////////////////////////
// FILTERS
/////////////////////////////////////////////////////////////////////////////

func (o Observable{{$name}}) adaptFilter(filter filters.Filter) Observable{{$name}} {
	observable := func(sink {{$name}}ObserverFunc) Subscribable {
		genericTo{{$name}}Sink := func(next interface{}, err error, completed bool) {
			if next{{$name}}, ok := next.({{$type}}); ok {
				sink(next{{$name}}, err, completed)
			} else {
				sink(zero{{$name}}, err, completed)
			}
		}
		genericToGenericFilter := filter(genericTo{{$name}}Sink)
		intToGenericSource := func(next {{$type}}, err error, completed bool) {
			genericToGenericFilter(next, err, completed)
		}
		return o(intToGenericSource)
	}
	return observable
}

// Distinct removes duplicate elements in the stream.
func (o Observable{{$name}}) Distinct() Observable{{$name}} {
	return o.adaptFilter(filters.Distinct())
}

// ElementAt yields the Nth element of the stream.
func (o Observable{{$name}}) ElementAt(n int) Observable{{$name}} {
	return o.adaptFilter(filters.ElementAt(n))
}

// Filter elements in the stream on a function.
func (o Observable{{$name}}) Filter(f func({{$type}}) bool) Observable{{$name}} {
	predicate := func(v interface{}) bool {
		return f(v.({{$type}}))
	}
	return o.adaptFilter(filters.Where(predicate))
}

// Last returns just the first element of the stream.
func (o Observable{{$name}}) First() Observable{{$name}} {
	return o.adaptFilter(filters.First())
}

// Last returns just the last element of the stream.
func (o Observable{{$name}}) Last() Observable{{$name}} {
	return o.adaptFilter(filters.Last())
}

// SkipLast skips the first N elements of the stream.
func (o Observable{{$name}}) Skip(n int) Observable{{$name}} {
	return o.adaptFilter(filters.Skip(n))
}

// SkipLast skips the last N elements of the stream.
func (o Observable{{$name}}) SkipLast(n int) Observable{{$name}} {
	return o.adaptFilter(filters.SkipLast(n))
}

// Take returns just the first N elements of the stream.
func (o Observable{{$name}}) Take(n int) Observable{{$name}} {
	return o.adaptFilter(filters.Take(n))
}

// TakeLast returns just the last N elements of the stream.
func (o Observable{{$name}}) TakeLast(n int) Observable{{$name}} {
	return o.adaptFilter(filters.TakeLast(n))
}

// IgnoreElements ignores elements of the stream and emits only the completion events.
func (o Observable{{$name}}) IgnoreElements() Observable{{$name}} {
	return o.adaptFilter(filters.IgnoreElements())
}

// IgnoreCompletion ignores the completion event of the stream and therefore returns a stream that never completes.
func (o Observable{{$name}}) IgnoreCompletion() Observable{{$name}} {
	observable := func(observer {{$name}}ObserverFunc) Subscribable {
		operator := func(next {{$type}}, err error, completed bool) {
			if !completed {
				observer(next, err, completed)
			}
		}
		return o(operator)
	}
	return observable
}

func (o Observable{{$name}}) One() Observable{{$name}} {
	return o.adaptFilter(filters.One())
}

func (o Observable{{$name}}) Replay(size int, duration time.Duration) Observable{{$name}} {
	if size == 0 {
		size = MaxReplaySize
	}
	return o.adaptFilter(filters.Replay(size, duration))
}

func (o Observable{{$name}}) Sample(duration time.Duration) Observable{{$name}} {
	return o.adaptFilter(filters.Sample(duration))
}

// Debounce reduces subsequent duplicates to single items during a certain duration
func (o Observable{{$name}}) Debounce(duration time.Duration) Observable{{$name}} {
	return o.adaptFilter(filters.Debounce(duration))
}

{{range $otherType := $.Types -}}
{{if eq $otherType "int" -}}
{{$otherName := $otherType|TypeName -}}
/////////////////////////////////////////////////////////////////////////////
// COUNT
/////////////////////////////////////////////////////////////////////////////

func (o Observable{{$name}}) Count() Observable{{$otherName}} {
	observable := func(observer {{$otherName}}ObserverFunc) Subscribable {
		count := 0
		operator := func(next {{$type}}, err error, completed bool) {
			if err != nil || completed {
				observer(count, nil, false)
				observer(zero{{$otherName}}, err, completed)
			}
			count++
		}
		return o(operator)
	}
	return observable
}

{{end -}}
{{end -}}

/////////////////////////////////////////////////////////////////////////////
// CONCAT
/////////////////////////////////////////////////////////////////////////////

func (o Observable{{$name}}) Concat(other ...Observable{{$name}}) Observable{{$name}} {
	if len(other) == 0 {
		return o
	}
	observable := func(observer {{$name}}ObserverFunc) Subscribable {
		unsubscribers := &unsubscriber.Collection{}

		var index int
		var maxIndex = 1 + len(other) - 1

		var wg sync.WaitGroup
		operator := func(next {{$type}}, err error, completed bool) {
			switch {
			case err != nil:
				index = maxIndex
				observer.Error(err)
				wg.Done()
			case completed:
				if index == maxIndex {
					observer.Complete()
				}
				wg.Done()
			default:
				observer.Next(next)
			}
		}

		subscribeOn := func(scheduler Scheduler) {
			// Execute the first observable on the passed in scheduler.
			wg.Add(1)
			subscribable := o(operator)
			if !unsubscribers.Set(subscribable) {
				return
			}
			subscribable.SubscribeOn(scheduler)
			wg.Wait()

			for i, observable := range other {
				index = i + 1
				wg.Add(1)
				unsubscriber := observable.Subscribe(operator)
				if !unsubscribers.Set(unsubscriber) {
					return
				}
				wg.Wait()
				if index == maxIndex {
					return
				}
			}
		}

		return Subscribable{subscribeOn, unsubscribers}
	}
	return observable
}

/////////////////////////////////////////////////////////////////////////////
// MERGE
/////////////////////////////////////////////////////////////////////////////

func (o Observable{{$name}}) merge(other []Observable{{$name}}, delayError bool) Observable{{$name}} {
	if len(other) == 0 {
		return o
	}
	observable := func(observer {{$name}}ObserverFunc) Subscribable {
		unsubscribers := &unsubscriber.Collection{}

		var (
			olock     sync.Mutex
			merged    int
			count     = 1 + len(other)
			lastError error
		)

		operator := func(next {{$type}}, err error, completed bool) {
			// Only one observable can be forwarding at any one time.
			olock.Lock()
			defer olock.Unlock()

			if merged >= count {
				return
			}

			switch {
			case err != nil:
				if delayError {
					lastError = err
					merged++
				} else {
					observer.Error(err)
					merged = count
					// tell all still executing observables, we're no longer interested
					unsubscribers.Unsubscribe()
				}

			case completed:
				merged++
				if merged == count {
					if lastError != nil {
						observer.Error(lastError)
					} else {
						observer.Complete()
					}
				}
			default:
				observer.Next(next)
			}
		}

		subscribeOn := func(scheduler Scheduler) {
			subscribable := o(operator)
			if !unsubscribers.Add(subscribable) {
				return
			}
			subscribable.SubscribeOn(scheduler)
			for _, observable := range other {
				unsubscriber := observable.Subscribe(operator)
				if !unsubscribers.Add(unsubscriber) {
					return
				}
			}
		}

		return Subscribable{subscribeOn, unsubscribers}
	}
	return observable
}

// Merge an arbitrary number of observables with this one.
// An error from any of the observables will terminate the merged stream.
func (o Observable{{$name}}) Merge(other ...Observable{{$name}}) Observable{{$name}} {
	return o.merge(other, false)
}

// Merge an arbitrary number of observables with this one.
// Any error will be deferred until all observables terminate.
func (o Observable{{$name}}) MergeDelayError(other ...Observable{{$name}}) Observable{{$name}} {
	return o.merge(other, true)
}

/////////////////////////////////////////////////////////////////////////////
// CATCH
/////////////////////////////////////////////////////////////////////////////

func (o Observable{{$name}}) Catch(catch Observable{{$name}}) Observable{{$name}} {
	observable := func(observer {{$name}}ObserverFunc) Subscribable {
		unsubscribers := &unsubscriber.Collection{}

		throwChan := make(chan error, 1)
		operator := func(next {{$type}}, err error, completed bool) {
			switch {
			case err != nil:
				throwChan <- err
			case completed:
				observer.Complete()
				throwChan <- nil
			default:
				observer.Next(next)
			}
		}

		catcher := func() {
			if err := <-throwChan; err != nil {
				unsubscriber := catch.Subscribe(observer)
				if !unsubscribers.Set(unsubscriber) {
					return
				}
			}
		}

		subscribeOn := func(scheduler Scheduler) {
			go catcher()

			subscribable := o(operator)
			if !unsubscribers.Set(subscribable) {
				return
			}
			subscribable.SubscribeOn(scheduler)
		}

		unsubscribe := func() {
			throwChan <- nil
		}
		unsubscribers.OnUnsubscribe(unsubscribe)

		return Subscribable{subscribeOn, unsubscribers}
	}
	return observable
}

/////////////////////////////////////////////////////////////////////////////
// RETRY
/////////////////////////////////////////////////////////////////////////////

func (o Observable{{$name}}) Retry() Observable{{$name}} {
	observable := func(observer {{$name}}ObserverFunc) Subscribable {
		unsubscribers := &unsubscriber.Collection{}

		throwChan := make(chan error, 1)
		operator := func(next {{$type}}, err error, completed bool) {
			switch {
			case err != nil:
				throwChan <- err
			case completed:
				observer.Complete()
				throwChan <- nil
			default:
				observer.Next(next)
			}
		}

		catcher := func(scheduler Scheduler) {
			for err := range throwChan {
				if err == nil {
					return
				}
				subscribable := o(operator)
				if !unsubscribers.Set(subscribable) {
					return
				}
				subscribable.SubscribeOn(scheduler)
			}
		}

		subscribeOn := func(scheduler Scheduler) {
			go catcher(scheduler)

			subscribable := o(operator)
			if !unsubscribers.Set(subscribable) {
				return
			}
			subscribable.SubscribeOn(scheduler)
		}

		unsubscribe := func() {
			throwChan <- nil
		}
		unsubscribers.OnUnsubscribe(unsubscribe)

		return Subscribable{subscribeOn, unsubscribers}
	}
	return observable
}

/////////////////////////////////////////////////////////////////////////////
// DO
/////////////////////////////////////////////////////////////////////////////

// Do applies a function for each value passing through the stream.
func (o Observable{{$name}}) Do(f func(next {{$type}})) Observable{{$name}} {
	observable := func(observer {{$name}}ObserverFunc) Subscribable {
		operator := func(next {{$type}}, err error, completed bool) {
			if err == nil && !completed {
				f(next)
			}
			observer(next, err, completed)
		}
		return o(operator)
	}
	return observable
}

// DoOnError applies a function for any error on the stream.
func (o Observable{{$name}}) DoOnError(f func(err error)) Observable{{$name}} {
	observable := func(observer {{$name}}ObserverFunc) Subscribable {
		operator := func(next {{$type}}, err error, completed bool) {
			if err != nil {
				f(err)
			}
			observer(next, err, completed)
		}
		return o(operator)
	}
	return observable
}

// DoOnComplete applies a function when the stream completes.
func (o Observable{{$name}}) DoOnComplete(f func()) Observable{{$name}} {
	observable := func(observer {{$name}}ObserverFunc) Subscribable {
		operator := func(next {{$type}}, err error, completed bool) {
			if completed {
				f()
			}
			observer(next, err, completed)
		}
		return o(operator)
	}
	return observable
}

// Finally applies a function for any error or completion on the stream.
// This doesn't expose whether this was an error or a completion.
func (o Observable{{$name}}) Finally(f func()) Observable{{$name}} {
	observable := func(observer {{$name}}ObserverFunc) Subscribable {
		operator := func(next {{$type}}, err error, completed bool) {
			if err != nil || completed {
				f()
			}
			observer(next, err, completed)
		}
		return o(operator)
	}
	return observable
}

/////////////////////////////////////////////////////////////////////////////
// REDUCE
/////////////////////////////////////////////////////////////////////////////

func (o Observable{{$name}}) Reduce(initial {{$type}}, reducer func({{$type}}, {{$type}}) {{$type}}) Observable{{$name}} {
	value := initial
	observable := func(observer {{$name}}ObserverFunc) Subscribable {
		operator := func(next {{$type}}, err error, completed bool) {
			if err != nil || completed {
				observer(value, nil, false)
				observer(zero{{$name}}, err, completed)
			} else {
				value = reducer(value, next)
			}
		}
		return o(operator)
	}
	return observable
}

/////////////////////////////////////////////////////////////////////////////
// SCAN
/////////////////////////////////////////////////////////////////////////////

func (o Observable{{$name}}) Scan(initial {{$type}}, f func({{$type}}, {{$type}}) {{$type}}) Observable{{$name}} {
	value := initial
	observable := func(observer {{$name}}ObserverFunc) Subscribable {
		operator := func(next {{$type}}, err error, completed bool) {
			if err != nil || completed {
				observer(zero{{$name}}, err, completed)
			} else {
				value = f(value, next)
				observer(value, nil, false)
			}
		}
		return o(operator)
	}
	return observable
}

/////////////////////////////////////////////////////////////////////////////
// TIMEOUT
/////////////////////////////////////////////////////////////////////////////

func (o Observable{{$name}}) Timeout(timeout time.Duration) Observable{{$name}} {
	observable := func(observer {{$name}}ObserverFunc) Subscribable {
		unsubscribers := &unsubscriber.Collection{}

		unsubchan := make(chan struct{})
		errchan := make(chan error)
		nextchan := make(chan {{$type}})
		deliver := func() {
			for {
				select {
				case <-unsubchan:
					return
				case <-time.After(timeout):
					observer(zero{{$name}}, ErrTimeout, false)
					unsubscribers.Unsubscribe()
					return
				case err := <-errchan:
					observer(zero{{$name}}, err, err == nil)
					unsubscribers.Unsubscribe()
					return
				case next := <-nextchan:
					observer(next, nil, false)
				}
			}
		}

		operator := func(next {{$type}}, err error, completed bool) {
			if err != nil || completed {
				errchan <- err
			} else {
				nextchan <- next
			}
		}

		subscribeOn := func(scheduler Scheduler) {
			go deliver()

			subscribable := o(operator)
			if !unsubscribers.Set(subscribable) {
				return
			}
			subscribable.SubscribeOn(scheduler)
		}

		unsubscribe := func() {
			close(unsubchan)
		}
		unsubscribers.OnUnsubscribe(unsubscribe)

		return Subscribable{subscribeOn, unsubscribers}
	}
	return observable
}

/////////////////////////////////////////////////////////////////////////////
// FORK
/////////////////////////////////////////////////////////////////////////////

// Fork replicates each event from the parent to every observer of the fork.
// This allows multiple subscriptions to a single observable.
func (o Observable{{$name}}) Fork() Observable{{$name}} {
	var observers struct {
		sync.Mutex
		items []{{$name}}ObserverFunc
	}

	addObserver := func(observer {{$name}}ObserverFunc) int {
		observers.Lock()
		defer observers.Unlock()
		index := len(observers.items)
		observers.items = append(observers.items, observer)
		return index
	}

	removeObserver := func(index int) {
		observers.Lock()
		defer observers.Unlock()
		observers.items[index] = nil
	}

	eachObserver := func(f func(observer {{$name}}ObserverFunc)) {
		observers.Lock()
		defer observers.Unlock()
		for _, observer := range observers.items {
			if observer != nil {
				f(observer)
			}
		}
	}

	operator := func(next {{$type}}, err error, completed bool) {
		eachObserver(func(observer {{$name}}ObserverFunc) {
			observer(next, err, completed)
		})
	}

	observable := func(observer {{$name}}ObserverFunc) Subscribable {
		unsubscribers := &unsubscriber.Collection{}
		index := addObserver(observer)

		subscribeOn := func(scheduler Scheduler) {
		}

		unsubscribe := func() {
			removeObserver(index)
		}
		unsubscribers.OnUnsubscribe(unsubscribe)

		return Subscribable{subscribeOn, unsubscribers}
	}

	// Subscribes immediately on creation of the observable.
	// So before anybody actually subscribed.
	o.Subscribe(operator)

	return observable
}

/////////////////////////////////////////////////////////////////////////////
// PUBLISH
/////////////////////////////////////////////////////////////////////////////

type Connectable{{$name}} struct {
	Observable{{$name}}
	connect func() Unsubscriber
}

// Connect will observable to the parent observable to start receiving values.
// All values will then be passed on to the observers that subscribed to this
// connectable observable
func (c Connectable{{$name}}) Connect() Unsubscriber {
	return c.connect()
}

// Publish creates a connectable observable that only starts emitting values
// after the Connect method is called on it.
func (o Observable{{$name}}) Publish() Connectable{{$name}} {
	var observers struct {
		sync.Mutex
		items []{{$name}}ObserverFunc
	}

	addObserver := func(observer {{$name}}ObserverFunc) int {
		observers.Lock()
		defer observers.Unlock()
		index := len(observers.items)
		observers.items = append(observers.items, observer)
		return index
	}

	removeObserver := func(index int) {
		observers.Lock()
		defer observers.Unlock()
		observers.items[index] = nil
	}

	eachObserver := func(f func(observer {{$name}}ObserverFunc)) {
		observers.Lock()
		defer observers.Unlock()
		for _, observer := range observers.items {
			if observer != nil {
				f(observer)
			}
		}
	}

	operator := func(next {{$type}}, err error, completed bool) {
		eachObserver(func(observer {{$name}}ObserverFunc) {
			observer(next, err, completed)
		})
	}

	observable := func(observer {{$name}}ObserverFunc) Subscribable {
		unsubscribers := &unsubscriber.Collection{}
		index := addObserver(observer)

		subscribeOn := func(scheduler Scheduler) {
		}

		unsubscribe := func() {
			removeObserver(index)
		}
		unsubscribers.OnUnsubscribe(unsubscribe)

		return Subscribable{subscribeOn, unsubscribers}
	}

	// Connect our operator observer function to the source start receiving
	// values from the source and forward them to our subscribers.
	connect := func() Unsubscriber {
		return o.Subscribe(operator)
	}

	return Connectable{{$name}}{Observable{{$name}}: observable, connect: connect}
}

{{if $type|IsNumeric -}}
/////////////////////////////////////////////////////////////////////////////
// MATHEMATICAL
/////////////////////////////////////////////////////////////////////////////

func (o Observable{{$name}}) Average() Observable{{$name}} {
	var sum {{$type}}
	var count {{$type}}
	observable := func(observer {{$name}}ObserverFunc) Subscribable {
		operator := func(next {{$type}}, err error, completed bool) {
			if err != nil || completed {
				observer(sum/count, nil, false)
				observer(zero{{$name}}, err, completed)
			} else {
				sum += next
				count++
			}
		}
		return o(operator)
	}
	return observable
}

func (o Observable{{$name}}) Sum() Observable{{$name}} {
	var sum {{$type}}
	observable := func(observer {{$name}}ObserverFunc) Subscribable {
		operator := func(next {{$type}}, err error, completed bool) {
			if err != nil || completed {
				observer(sum, nil, false)
				observer(zero{{$name}}, err, completed)
			} else {
				sum += next
			}
		}
		return o(operator)
	}
	return observable
}

func (o Observable{{$name}}) Min() Observable{{$name}} {
	started := false
	var min {{$type}}
	observable := func(observer {{$name}}ObserverFunc) Subscribable {
		operator := func(next {{$type}}, err error, completed bool) {
			if err != nil || completed {
				if started {
					observer(min, nil, false)
				}
				observer(zero{{$name}}, err, completed)
			} else {
				if started {
					if min > next {
						min = next
					}
				} else {
					min = next
					started = true
				}
			}
		}
		return o(operator)
	}
	return observable
}

func (o Observable{{$name}}) Max() Observable{{$name}} {
	started := false
	var max {{$type}}
	observable := func(observer {{$name}}ObserverFunc) Subscribable {
		operator := func(next {{$type}}, err error, completed bool) {
			if err != nil || completed {
				if started {
					observer(max, nil, false)
				}
				observer(zero{{$name}}, err, completed)
			} else {
				if started {
					if max < next {
						max = next
					}
				} else {
					max = next
					started = true
				}
			}
		}
		return o(operator)
	}
	return observable
}

{{end -}}

{{range $otherType := $.MapTypes -}}
{{$otherName := $otherType|TypeName -}}
/////////////////////////////////////////////////////////////////////////////
// MAP ({{$type}},{{$otherType}})
/////////////////////////////////////////////////////////////////////////////

func (o Observable{{$name}}) Map{{$otherName}}(f func({{$type}}) {{$otherType}}) Observable{{$otherName}} {
	observable := func(observer {{$otherName}}ObserverFunc) Subscribable {
		operator := func(next {{$type}}, err error, completed bool) {
			var mapped {{$otherType}}
			if err == nil && !completed {
				mapped = f(next)
			}
			observer(mapped, err, completed)
		}
		return o(operator)
	}
	return observable
}

/////////////////////////////////////////////////////////////////////////////
// FLATMAP ({{$type}},{{$otherName}})
/////////////////////////////////////////////////////////////////////////////

func (o Observable{{$name}}) FlatMap{{$otherName}}(f func({{$type}}) Observable{{$otherName}}) Observable{{$otherName}} {
	observable := func(observer {{$otherName}}ObserverFunc) Subscribable {
		unsubscribers := &unsubscriber.Collection{}

		var wait struct {
			sync.Mutex
			Condition *sync.Cond
			Accum     int
		}
		wait.Condition = sync.NewCond(&wait.Mutex)

		waitForZero := func() bool {
			wait.Lock()
			defer wait.Unlock()
			for wait.Accum > 0 {
				wait.Condition.Wait()
			}
			return (wait.Accum == 0)
		}

		waitAdd := func() {
			wait.Lock()
			defer wait.Unlock()
			wait.Accum++
			wait.Condition.Broadcast()
		}

		waitDone := func() {
			wait.Lock()
			defer wait.Unlock()
			wait.Accum--
			wait.Condition.Broadcast()
		}

		waitCancel := func() {
			wait.Lock()
			defer wait.Unlock()
			wait.Accum = -1
			wait.Condition.Broadcast()
		}

		var lock sync.Mutex
		flatten := func(next {{$otherType}}, err error, completed bool) {
			lock.Lock()
			defer lock.Unlock()
			// Finally
			if err != nil || completed {
				waitDone()
			}
			// IgnoreCompletion
			if !completed {
				observer(next, err, completed)
			}
		}

		operator := func(next {{$type}}, err error, completed bool) {
			if err != nil || completed {
				if waitForZero() {
					observer(zero{{$otherName}}, err, err == nil)
				}
			} else {
				waitAdd()
				unsubscriber := f(next).Subscribe(flatten)
				if !unsubscribers.Add(unsubscriber) {
					return
				}

			}
		}

		subscribeOn := func(scheduler Scheduler) {
			subscribable := o(operator)
			if !unsubscribers.Add(subscribable) {
				return
			}
			subscribable.SubscribeOn(scheduler)
		}

		unsubscribe := func() {
			waitCancel()
		}
		unsubscribers.OnUnsubscribe(unsubscribe)

		return Subscribable{subscribeOn, unsubscribers}
	}
	return observable
}

{{end -}}
{{end -}}
