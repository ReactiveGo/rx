// NOTE: This file was generated by rxgo. Do not modify.

// Package {{.Package}} implements ReactiveX extensions for Go.
package {{.Package}}

//go:generate {{.Generate|Join}}

import (
	"errors"
	"rxgo/filters"
	"rxgo/scheduler"
	"rxgo/unsubscriber"
	"sync"
	"time"
{{- range .Imports}}
	"{{.}}"
{{- end}}
)

// ErrTimeout is delivered to an observer if the stream times out.
var ErrTimeout = errors.New("timeout")

// MaxReplaySize is the maximum size of a replay buffer. Can be modified.
var MaxReplaySize = {{.MaxReplaySize}}

type Scheduler scheduler.Scheduler

type Unsubscriber unsubscriber.Unsubscriber

{{range $type := .Types -}}
{{$name := $type|TypeName -}}
////////////////////////////////////////////////////////
// {{$name}}Observer
////////////////////////////////////////////////////////

type {{$name}}Observer interface {
	Next({{$type}})
	Error(error)
	Complete()
	Unsubscribed() bool
}

type {{$name}}ObserverFunc func({{$type}}, error, bool)

var zero{{$name}} {{$type}}

func (f {{$name}}ObserverFunc) Next(next {{$type}}) {
	f(next, nil, false)
}

func (f {{$name}}ObserverFunc) Error(err error) {
	f(zero{{$name}}, err, err==nil)
}

func (f {{$name}}ObserverFunc) Complete() {
	f(zero{{$name}}, nil, true)
}

////////////////////////////////////////////////////////
// Observable{{$name}}
////////////////////////////////////////////////////////

// Every observable is essentially a function taking an
// Observer function, scheduler and an unsubscriber.
type Observable{{$name}} func({{$name}}ObserverFunc, Scheduler, Unsubscriber)

/////////////////////////////////////////////////////////////////////////////
// FROM
/////////////////////////////////////////////////////////////////////////////

// Create{{$name}} calls f(observer) to produce values for a stream of ints.
func Create{{$name}}(f func({{$name}}Observer)) Observable{{$name}} {
	observable := func(observer {{$name}}ObserverFunc, scheduler Scheduler, unsubscriber Unsubscriber) {
		scheduler.Schedule(func() {
			if !unsubscriber.Unsubscribed() {
				operation := func(next {{$type}}, err error, completed bool) {
					if !unsubscriber.Unsubscribed() {
						observer(next, err, completed)
					}
				}
				observer := &struct {
					{{$name}}ObserverFunc
					Unsubscriber
				}{operation, unsubscriber}
				f(observer)
			}
		})
	}
	return observable
}

func Empty{{$name}}() Observable{{$name}} {
	return Create{{$name}}(func(observer {{$name}}Observer) {
		observer.Complete()
	})
}

func Never{{$name}}() Observable{{$name}} {
	return Create{{$name}}(func(observer {{$name}}Observer) {
	})
}

func Throw{{$name}}(err error) Observable{{$name}} {
	return Create{{$name}}(func(observer {{$name}}Observer) {
		observer.Error(err)
	})
}

func From{{$name}}Array(array []{{$type}}) Observable{{$name}} {
	return Create{{$name}}(func(observer {{$name}}Observer) {
		for _, next := range array {
			if observer.Unsubscribed() {
				return
			}
			observer.Next(next)
		}
		observer.Complete()
	})
}

func From{{$name}}s(array ...{{$type}}) Observable{{$name}} {
	return From{{$name}}Array(array)
}

func From{{$name}}Channel(ch <-chan {{$type}}) Observable{{$name}} {
	return Create{{$name}}(func(observer {{$name}}Observer) {
		for next := range ch {
			if observer.Unsubscribed() {
				return
			}
			observer.Next(next)
		}
		observer.Complete()
	})
}

func From{{$name}}ChannelWithError(data <-chan {{$type}}, errs <-chan error) Observable{{$name}} {
	return Create{{$name}}(func(observer {{$name}}Observer) {
		for {
			select {
			case next, ok := <-data:
				if observer.Unsubscribed() {
					return
				}
				if ok {
					observer.Next(next)
				} else {
					data = nil
					observer.Complete()
					return
				}
			case err, ok := <-errs:
				if observer.Unsubscribed() {
					return
				}
				if ok {
					if err != nil {
						observer.Error(err)
						return
					}
				} else {
					errs = nil
				}
			}
		}	})
}

{{if eq $type "int" -}}
func Interval(interval time.Duration) Observable{{$name}} {
	return Create{{$name}}(func(observer {{$name}}Observer) {
		for i := 0; ; i++ {
			time.Sleep(interval)
			if observer.Unsubscribed() {
				return
			}
			observer.Next(i)
		}
	})
}

{{end -}}

func Just{{$name}}(element {{$type}}) Observable{{$name}} {
	return Create{{$name}}(func(observer {{$name}}Observer) {
		observer.Next(element)
		observer.Complete()
	})
}

{{if eq $type "int" -}}
func Range(start, count int) Observable{{$name}} {
	end := start + count
	return Create{{$name}}(func(observer {{$name}}Observer) {
		for i := start; i < end; i++ {
			if observer.Unsubscribed() {
				return
			}
			observer.Next(i)
		}
		observer.Complete()
	})
}

{{end -}}

// Repeat value count times.
func Repeat{{$name}}(value {{$type}}, count int) Observable{{$name}} {
	return Create{{$name}}(func(observer {{$name}}Observer) {
		for i := 0; i < count; i++ {
			if observer.Unsubscribed() {
				return
			}
			observer.Next(value)
		}
		observer.Complete()
	})
}

// Start{{$name}} is designed to be used with functions that return a
// ({{$type}}, error) tuple.
//
// If the error is non-nil the returned Observable{{$name}} will be that error,
// otherwise it will be a single-value stream of {{$type}}.
func Start{{$name}}(f func() ({{$type}}, error)) Observable{{$name}} {
	return Create{{$name}}(func(observer {{$name}}Observer) {
		if next, err := f(); err != nil {
			observer.Error(err)
		} else {
			observer.Next(next)
			observer.Complete()
		}
	})
}

func Merge{{$name}}(observables ...Observable{{$name}}) Observable{{$name}} {
	if len(observables) == 0 {
		return Empty{{$name}}()
	}
	return observables[0].Merge(observables[1:]...)
}

func Merge{{$name}}DelayError(observables ...Observable{{$name}}) Observable{{$name}} {
	if len(observables) == 0 {
		return Empty{{$name}}()
	}
	return observables[0].MergeDelayError(observables[1:]...)
}

/////////////////////////////////////////////////////////////////////////////
// Subscribe
/////////////////////////////////////////////////////////////////////////////

func (o Observable{{$name}}) SubscribeOn(scheduler Scheduler) Observable{{$name}} {
	observable := func(observer {{$name}}ObserverFunc, _ Scheduler, unsubscriber Unsubscriber) {
		// override the scheduler
		o(observer, scheduler, unsubscriber)
	}
	return observable
}

// Subscribe an observer function to the observable.
// This method returns an Unsubscriber. You can always call Unsubscribe
// on the returned Unsubscriber to make sure all resources (goroutines)
// are deallocated. If the subscription terminates naturally because
// of an error or when the stream of data is complete then the Unsubscribe
// method on the Unsubscriber is automatically called internally.
func (o Observable{{$name}}) Subscribe(observer {{$name}}ObserverFunc) Unsubscriber {
	unsubscriber := unsubscriber.New()
	operator := func(next {{$type}}, err error, completed bool) {
		observer(next, err, completed)
		if err != nil || completed {
			unsubscriber.Unsubscribe()
		}
	}
	o(operator, scheduler.Goroutines, unsubscriber)
	return unsubscriber
}

func (o Observable{{$name}}) SubscribeNext(f func(v {{$type}})) Unsubscriber {
	operator := func(next {{$type}}, err error, completed bool) {
		if err == nil && !completed {
			f(next)
		}
	}
	return o.Subscribe(operator)
}

// Wait for completion of the stream and return any error.
func (o Observable{{$name}}) Wait() error {
	doneChan := make(chan error)
	operator := func(next {{$type}}, err error, completed bool) {
		if err != nil || completed {
			doneChan <- err
		}
	}
	o.Subscribe(operator)
	return <-doneChan
}

/////////////////////////////////////////////////////////////////////////////
// TO
/////////////////////////////////////////////////////////////////////////////

// ToOneWithError blocks until the stream emits exactly one value. Otherwise, it errors.
func (o Observable{{$name}}) ToOneWithError() (v {{$type}}, e error) {
	v = zero{{$name}}
	errch := make(chan error, 1)
	o.One().Subscribe(func(next {{$type}}, err error, completed bool) {
		if err != nil || completed {
			errch <- err
			// Close errch to make subsequent use of it panic. This will prevent
			// a coroutine inside an observable getting stuck on errch and leaking.
			close(errch)
		} else {
			v = next
		}
	})
	e = <-errch
	return
}

// ToOne blocks and returns the only value emitted by the stream, or the zero
// value if an error occurs.
func (o Observable{{$name}}) ToOne() {{$type}} {
	value, _ := o.ToOneWithError()
	return value
}

// ToArrayWithError collects all values from the stream into an array,
// returning it and any error.
func (o Observable{{$name}}) ToArrayWithError() (a []{{$type}}, e error) {
	a = []{{$type}}{}
	errch := make(chan error, 1)
	o.Subscribe(func(next {{$type}}, err error, completed bool) {
		if err != nil || completed {
			errch <- err
			// Close errch to make subsequent use of it panic. This will prevent
			// a coroutine inside an observable getting stuck on errch and leaking.
			close(errch)
		} else {
			a = append(a, next)
		}
	})
	e = <-errch
	return
}

// ToArray blocks and returns the values from the stream in an array.
func (o Observable{{$name}}) ToArray() []{{$type}} {
	out, _ := o.ToArrayWithError()
	return out
}

// ToChannelWithError returns next and error channels corresponding to the stream elements and
// any error. When the next channel closes, it may be either because of an error or
// because the observable completed. The next channel may be closed without having emitted any
// values. The error channel always emits a value to indicate the observable has finished.
// When the error channel emits nil then the observable completed without errors, otherwise
// the error channel emits the error. When the observable has finished both channels will be
// closed.
func (o Observable{{$name}}) ToChannelWithError() (<-chan {{$type}}, <-chan error) {
	nextch := make(chan {{$type}}, 1)
	errch := make(chan error, 1)
	o.Subscribe(func(next {{$type}}, err error, completed bool) {
		if err != nil || completed {
			errch <- err
			close(errch)
			close(nextch)
		} else {
			nextch <- next
		}
	})
	return nextch, errch
}

func (o Observable{{$name}}) ToChannel() <-chan {{$type}} {
	ch, _ := o.ToChannelWithError()
	return ch
}

/////////////////////////////////////////////////////////////////////////////
// FILTERS
/////////////////////////////////////////////////////////////////////////////

func (o Observable{{$name}}) adaptFilter(filter filters.Filter) Observable{{$name}} {
	observable := func(sink {{$name}}ObserverFunc, scheduler Scheduler, unsubscriber Unsubscriber) {
		genericTo{{$name}}Sink := func(next interface{}, err error, completed bool) {
			if next{{$name}}, ok := next.({{$type}}); ok {
				sink(next{{$name}}, err, completed)
			} else {
				sink(zero{{$name}}, err, completed)
			}
		}
		genericToGenericFilter := filter(genericTo{{$name}}Sink)
		intToGenericSource := func(next {{$type}}, err error, completed bool) {
			genericToGenericFilter(next, err, completed)
		}
		o(intToGenericSource, scheduler, unsubscriber)
	}
	return observable
}

// Distinct removes duplicate elements in the stream.
func (o Observable{{$name}}) Distinct() Observable{{$name}} {
	return o.adaptFilter(filters.Distinct())
}

// ElementAt yields the Nth element of the stream.
func (o Observable{{$name}}) ElementAt(n int) Observable{{$name}} {
	return o.adaptFilter(filters.ElementAt(n))
}

// Filter elements in the stream on a function.
func (o Observable{{$name}}) Filter(f func({{$type}}) bool) Observable{{$name}} {
	predicate := func(v interface{}) bool {
		return f(v.({{$type}}))
	}
	return o.adaptFilter(filters.Where(predicate))
}

// Last returns just the first element of the stream.
func (o Observable{{$name}}) First() Observable{{$name}} {
	return o.adaptFilter(filters.First())
}

// Last returns just the last element of the stream.
func (o Observable{{$name}}) Last() Observable{{$name}} {
	return o.adaptFilter(filters.Last())
}

// SkipLast skips the first N elements of the stream.
func (o Observable{{$name}}) Skip(n int) Observable{{$name}} {
	return o.adaptFilter(filters.Skip(n))
}

// SkipLast skips the last N elements of the stream.
func (o Observable{{$name}}) SkipLast(n int) Observable{{$name}} {
	return o.adaptFilter(filters.SkipLast(n))
}

// Take returns just the first N elements of the stream.
func (o Observable{{$name}}) Take(n int) Observable{{$name}} {
	return o.adaptFilter(filters.Take(n))
}

// TakeLast returns just the last N elements of the stream.
func (o Observable{{$name}}) TakeLast(n int) Observable{{$name}} {
	return o.adaptFilter(filters.TakeLast(n))
}

// IgnoreElements ignores elements of the stream and emits only the completion events.
func (o Observable{{$name}}) IgnoreElements() Observable{{$name}} {
	return o.adaptFilter(filters.IgnoreElements())
}

// IgnoreCompletion ignores the completion event of the stream and therefore returns a stream that never completes.
func (o Observable{{$name}}) IgnoreCompletion() Observable{{$name}} {
	return o.adaptFilter(filters.IgnoreCompletion())
}

func (o Observable{{$name}}) One() Observable{{$name}} {
	return o.adaptFilter(filters.One())
}

func (o Observable{{$name}}) Replay(size int, duration time.Duration) Observable{{$name}} {
	if size == 0 {
		size = MaxReplaySize
	}
	return o.adaptFilter(filters.Replay(size, duration))
}

func (o Observable{{$name}}) Sample(duration time.Duration) Observable{{$name}} {
	return o.adaptFilter(filters.Sample(duration))
}

// Debounce reduces subsequent duplicates to single items during a certain duration
func (o Observable{{$name}}) Debounce(duration time.Duration) Observable{{$name}} {
	return o.adaptFilter(filters.Debounce(duration))
}

{{range $otherType := $.Types -}}
{{if eq $otherType "int" -}}
{{$otherName := $otherType|TypeName -}}
/////////////////////////////////////////////////////////////////////////////
// COUNT
/////////////////////////////////////////////////////////////////////////////

func (o Observable{{$name}}) Count() Observable{{$otherName}} {
	observable := func(observer {{$otherName}}ObserverFunc, scheduler Scheduler, unsubscriber Unsubscriber) {
		count := 0
		operator := func(next {{$type}}, err error, completed bool) {
			if err != nil || completed {
				observer(count, nil, false)
				observer(zero{{$otherName}}, err, completed)
			}
			count++
		}
		o(operator, scheduler, unsubscriber)
	}
	return observable
}

{{end -}}
{{end -}}

/////////////////////////////////////////////////////////////////////////////
// CONCAT
/////////////////////////////////////////////////////////////////////////////

func (o Observable{{$name}}) Concat(other ...Observable{{$name}}) Observable{{$name}} {
	if len(other) == 0 {
		return o
	}
	observable := func(observer {{$name}}ObserverFunc, sched Scheduler, unsub Unsubscriber) {
		var index int
		var maxIndex = 1 + len(other) - 1

		operator := func(next {{$type}}, err error, completed bool) {
			switch {
			case err != nil:
				index = maxIndex
				observer.Error(err)
			case completed:
				if index == maxIndex {
					observer.Complete()
				}
			default:
				observer.Next(next)
			}
		}

		// Execute the concat on the passed in scheduler.
		sched.Schedule(func() {
			o(operator, scheduler.Immediate, unsub)
			if index == maxIndex {
				return
			}			
			for i, observable := range other {
				index = i + 1
				observable(operator, scheduler.Immediate, unsub)
				if index == maxIndex {
					return
				}
			}
		})
	}
	return observable
}

/////////////////////////////////////////////////////////////////////////////
// MERGE
/////////////////////////////////////////////////////////////////////////////

func (o Observable{{$name}}) merge(other []Observable{{$name}}, delayError bool) Observable{{$name}} {
	if len(other) == 0 {
		return o
	}
	observable := func(observer {{$name}}ObserverFunc, scheduler Scheduler, unsubscriber Unsubscriber) {
		var (
			olock     sync.Mutex
			merged    int
			count     = 1 + len(other)
			lastError error
		)

		operator := func(next {{$type}}, err error, completed bool) {
			// Only one observable can be forwarding at any one time.
			olock.Lock()
			defer olock.Unlock()

			if merged >= count {
				return
			}

			switch {
			case err != nil:
				if delayError {
					lastError = err
					merged++
				} else {
					observer.Error(err)
					merged = count
				}

			case completed:
				merged++
				if merged == count {
					if lastError != nil {
						observer.Error(lastError)
					} else {
						observer.Complete()
					}
				}
			default:
				observer.Next(next)
			}
		}

		o(operator, scheduler, unsubscriber)
		for _, o := range other {
			o(operator, scheduler, unsubscriber)
		}
	}
	return observable
}

// Merge an arbitrary number of observables with this one.
// An error from any of the observables will terminate the merged stream.
func (o Observable{{$name}}) Merge(other ...Observable{{$name}}) Observable{{$name}} {
	return o.merge(other, false)
}

// Merge an arbitrary number of observables with this one.
// Any error will be deferred until all observables terminate.
func (o Observable{{$name}}) MergeDelayError(other ...Observable{{$name}}) Observable{{$name}} {
	return o.merge(other, true)
}

/////////////////////////////////////////////////////////////////////////////
// CATCH
/////////////////////////////////////////////////////////////////////////////

func (o Observable{{$name}}) Catch(catch Observable{{$name}}) Observable{{$name}} {
	observable := func(observer {{$name}}ObserverFunc, sched Scheduler, unsub Unsubscriber) {
		operator := func(next {{$type}}, err error, completed bool) {
			if err != nil {
				catch(observer, scheduler.Immediate, unsub)
			} else {
				observer(next, err, completed)
			}
		}
		o(operator, sched, unsub)
	}
	return observable
}

/////////////////////////////////////////////////////////////////////////////
// RETRY
/////////////////////////////////////////////////////////////////////////////

func (o Observable{{$name}}) Retry() Observable{{$name}} {
	observable := func(observer {{$name}}ObserverFunc, sched Scheduler, unsub Unsubscriber) {
		sched.Schedule(func() {
			if !unsub.Unsubscribed() {
				var done bool
				operator := func(next {{$type}}, err error, completed bool) {
					if err == nil {
						observer(next, err, completed)
						done = completed
					}
				}
				for !unsub.Unsubscribed() && !done {
					o(operator, scheduler.Immediate, unsub)
				}
			}
		})
	}
	return observable
}

/////////////////////////////////////////////////////////////////////////////
// DO
/////////////////////////////////////////////////////////////////////////////

// Do applies a function for each value passing through the stream.
func (o Observable{{$name}}) Do(f func(next {{$type}})) Observable{{$name}} {
	observable := func(observer {{$name}}ObserverFunc, scheduler Scheduler, unsubscriber Unsubscriber) {
		operator := func(next {{$type}}, err error, completed bool) {
			if err == nil && !completed {
				f(next)
			}
			observer(next, err, completed)
		}
		o(operator, scheduler, unsubscriber)
	}
	return observable
}

// DoOnError applies a function for any error on the stream.
func (o Observable{{$name}}) DoOnError(f func(err error)) Observable{{$name}} {
	observable := func(observer {{$name}}ObserverFunc, scheduler Scheduler, unsubscriber Unsubscriber) {
		operator := func(next {{$type}}, err error, completed bool) {
			if err != nil {
				f(err)
			}
			observer(next, err, completed)
		}
		o(operator, scheduler, unsubscriber)
	}
	return observable
}

// DoOnComplete applies a function when the stream completes.
func (o Observable{{$name}}) DoOnComplete(f func()) Observable{{$name}} {
	observable := func(observer {{$name}}ObserverFunc, scheduler Scheduler, unsubscriber Unsubscriber) {
		operator := func(next {{$type}}, err error, completed bool) {
			if completed {
				f()
			}
			observer(next, err, completed)
		}
		o(operator, scheduler, unsubscriber)
	}
	return observable
}

// Finally applies a function for any error or completion on the stream.
// This doesn't expose whether this was an error or a completion.
func (o Observable{{$name}}) Finally(f func()) Observable{{$name}} {
	observable := func(observer {{$name}}ObserverFunc, scheduler Scheduler, unsubscriber Unsubscriber) {
		operator := func(next {{$type}}, err error, completed bool) {
			if err != nil || completed {
				f()
			}
			observer(next, err, completed)
		}
		o(operator, scheduler, unsubscriber)
	}
	return observable
}

/////////////////////////////////////////////////////////////////////////////
// REDUCE
/////////////////////////////////////////////////////////////////////////////

func (o Observable{{$name}}) Reduce(initial {{$type}}, reducer func({{$type}}, {{$type}}) {{$type}}) Observable{{$name}} {
	observable := func(observer {{$name}}ObserverFunc, scheduler Scheduler, unsubscriber Unsubscriber) {
		value := initial
		operator := func(next {{$type}}, err error, completed bool) {
			if err != nil || completed {
				observer(value, nil, false)
				observer(zero{{$name}}, err, completed)
			} else {
				value = reducer(value, next)
			}
		}
		o(operator, scheduler, unsubscriber)
	}
	return observable
}

/////////////////////////////////////////////////////////////////////////////
// SCAN
/////////////////////////////////////////////////////////////////////////////

func (o Observable{{$name}}) Scan(initial {{$type}}, f func({{$type}}, {{$type}}) {{$type}}) Observable{{$name}} {
	observable := func(observer {{$name}}ObserverFunc, scheduler Scheduler, unsubscriber Unsubscriber) {
		value := initial
		operator := func(next {{$type}}, err error, completed bool) {
			if err != nil || completed {
				observer(zero{{$name}}, err, completed)
			} else {
				value = f(value, next)
				observer(value, nil, false)
			}
		}
		o(operator, scheduler, unsubscriber)
	}
	return observable
}

/////////////////////////////////////////////////////////////////////////////
// TIMEOUT
/////////////////////////////////////////////////////////////////////////////

func (o Observable{{$name}}) Timeout(timeout time.Duration) Observable{{$name}} {
	observable := func(observer {{$name}}ObserverFunc, scheduler Scheduler, unsubscriber Unsubscriber) {

		if scheduler.Asynchronous() {
			// Asynchronous, so all scheduled tasks are executed in parallel.
			unsubscriber := unsubscriber.AddChild()

			deadline := time.NewTimer(timeout)

			var lock sync.Mutex
			operator := func(next {{$type}}, err error, completed bool) {
				lock.Lock()
				defer lock.Unlock()

				if deadline.Stop() {
					// next data received before deadline expired.
					observer(next, err, completed)
					deadline.Reset(timeout)
				} else {
					// unfortunately the deadline has expired.
					observer.Error(ErrTimeout)
					unsubscriber.Unsubscribe()
				}
			}

			scheduler.Schedule(func() {
				<-deadline.C
				{{$name}}ObserverFunc(operator).Error(ErrTimeout)
			})

			o(operator, scheduler, unsubscriber)

		} else {
			// Synchronous, meaning all Scheduled tasks are executed in sequence.
			unsubscriber := unsubscriber.AddChild()
			lastTime := time.Now()
			operator := func(next {{$type}}, err error, completed bool) {
				if time.Since(lastTime) > timeout {
					unsubscriber.Unsubscribe()
					observer.Error(ErrTimeout)
				} else {
					observer(next, err, completed)
					lastTime = time.Now()
				}
			}
			o(operator, scheduler, unsubscriber)
		}
	}
	return observable
}

/////////////////////////////////////////////////////////////////////////////
// FORK
/////////////////////////////////////////////////////////////////////////////

// Fork replicates each event from the parent to every observer of the fork.
// This allows multiple subscriptions to a single observable.
// This only works for hot observables, cold observables may drain out to the
// first connected observable even before a subsequent observer subscribes.
func (o Observable{{$name}}) Fork() Observable{{$name}} {
	fork := o.Publish()
	// TODO: Nobody can actually Unsubscribe from this thing....
	fork.Connect()
	return fork.Observable{{$name}}
}

/////////////////////////////////////////////////////////////////////////////
// PUBLISH
/////////////////////////////////////////////////////////////////////////////

type Connectable{{$name}} struct {
	Observable{{$name}}
	connect func() Unsubscriber
}

// Connect will observable to the parent observable to start receiving values.
// All values will then be passed on to the observers that subscribed to this
// connectable observable
func (c Connectable{{$name}}) Connect() Unsubscriber {
	return c.connect()
}

// Publish creates a connectable observable that only starts emitting values
// after the Connect method is called on it.
func (o Observable{{$name}}) Publish() Connectable{{$name}} {

	type channel struct {
		data chan {{$type}}
		errs chan error
	}

	var channels struct {
		sync.Mutex
		items []*channel
	}

	addChannel := func(data chan {{$type}}, errs chan error) int {
		channels.Lock()
		defer channels.Unlock()
		index := len(channels.items)
		channels.items = append(channels.items, &channel{data, errs})
		return index
	}

	removeChannel := func(index int) {
		channels.Lock()
		defer channels.Unlock()
		ch := channels.items[index]
		if ch != nil {
			if ch.data != nil {
				close(ch.data)
			}
			channels.items[index] = nil
		}
	}

	removeAllChannels := func() {
		channels.Lock()
		defer channels.Unlock()
		for index, ch := range channels.items {
			if ch != nil {
				if ch.data != nil {
					close(ch.data)
				}
				channels.items[index] = nil
			}
		}
	}

	broadcastData := func(next {{$type}}) {
		channels.Lock()
		defer channels.Unlock()
		for _, ch := range channels.items {
			if ch != nil {
				if ch.data != nil {
					ch.data <- next
				}
			}
		}
	}

	broadcastError := func(err error) {
		channels.Lock()
		defer channels.Unlock()
		for _, ch := range channels.items {
			if ch != nil {
				if ch.errs != nil {
					ch.errs <- err
				}
			}
		}
	}

	operator := func(next {{$type}}, err error, completed bool) {
		switch {
		case err != nil:
			broadcastError(err)
		case completed:
			removeAllChannels()
		default:
			broadcastData(next)
		}
	}

	// Connect our operator observer function to the source start receiving
	// values from the source and forward them to our subscribers.
	connect := func() Unsubscriber {
		// TODO: Can Connect() Unsubscribe() Connect() sequence be used to pause/restart the stream?
		return o.Subscribe(operator)
	}

	observable := func(observer {{$name}}ObserverFunc, scheduler Scheduler, unsubscriber Unsubscriber) {
		data := make(chan {{$type}}, 1)
		errs := make(chan error, 1)
		index := addChannel(data, errs)
		unsubscriber.OnUnsubscribe(func() {
			removeChannel(index)
		})
		From{{$name}}ChannelWithError(data, errs)(observer, scheduler, unsubscriber)
	}

	return Connectable{{$name}}{Observable{{$name}}: observable, connect: connect}
}

{{if $type|IsNumeric -}}
/////////////////////////////////////////////////////////////////////////////
// MATHEMATICAL
/////////////////////////////////////////////////////////////////////////////

func (o Observable{{$name}}) Average() Observable{{$name}} {
	observable := func(observer {{$name}}ObserverFunc, scheduler Scheduler, unsubscriber Unsubscriber) {
		var sum {{$type}}
		var count {{$type}}
		operator := func(next {{$type}}, err error, completed bool) {
			if err != nil || completed {
				observer(sum/count, nil, false)
				observer(zero{{$name}}, err, completed)
			} else {
				sum += next
				count++
			}
		}
		o(operator, scheduler, unsubscriber)
	}
	return observable
}

func (o Observable{{$name}}) Sum() Observable{{$name}} {
	observable := func(observer {{$name}}ObserverFunc, scheduler Scheduler, unsubscriber Unsubscriber) {
		var sum {{$type}}
		operator := func(next {{$type}}, err error, completed bool) {
			if err != nil || completed {
				observer(sum, nil, false)
				observer(zero{{$name}}, err, completed)
			} else {
				sum += next
			}
		}
		o(operator, scheduler, unsubscriber)
	}
	return observable
}

func (o Observable{{$name}}) Min() Observable{{$name}} {
	observable := func(observer {{$name}}ObserverFunc, scheduler Scheduler, unsubscriber Unsubscriber) {
		started := false
		var min {{$type}}
		operator := func(next {{$type}}, err error, completed bool) {
			if err != nil || completed {
				if started {
					observer(min, nil, false)
				}
				observer(zero{{$name}}, err, completed)
			} else {
				if started {
					if min > next {
						min = next
					}
				} else {
					min = next
					started = true
				}
			}
		}
		o(operator, scheduler, unsubscriber)
	}
	return observable
}

func (o Observable{{$name}}) Max() Observable{{$name}} {
	observable := func(observer {{$name}}ObserverFunc, scheduler Scheduler, unsubscriber Unsubscriber) {
		started := false
		var max {{$type}}
		operator := func(next {{$type}}, err error, completed bool) {
			if err != nil || completed {
				if started {
					observer(max, nil, false)
				}
				observer(zero{{$name}}, err, completed)
			} else {
				if started {
					if max < next {
						max = next
					}
				} else {
					max = next
					started = true
				}
			}
		}
		o(operator, scheduler, unsubscriber)
	}
	return observable
}

{{end -}}

{{range $otherType := $.MapTypes -}}
{{$otherName := $otherType|TypeName -}}
/////////////////////////////////////////////////////////////////////////////
// MAP ({{$type}},{{$otherType}})
/////////////////////////////////////////////////////////////////////////////

func (o Observable{{$name}}) Map{{$otherName}}(f func({{$type}}) {{$otherType}}) Observable{{$otherName}} {
	observable := func(observer {{$otherName}}ObserverFunc, scheduler Scheduler, unsubscriber Unsubscriber) {
		operator := func(next {{$type}}, err error, completed bool) {
			var mapped {{$otherType}}
			if err == nil && !completed {
				mapped = f(next)
			}
			observer(mapped, err, completed)
		}
		o(operator, scheduler, unsubscriber)
	}
	return observable
}

{{end -}}

{{range $otherType := $.MapTypes -}}
{{$otherName := $otherType|TypeName -}}
/////////////////////////////////////////////////////////////////////////////
// FLATMAP ({{$type}},{{$otherType}})
/////////////////////////////////////////////////////////////////////////////

func (o Observable{{$name}}) FlatMap{{$otherName}}(f func({{$type}}) Observable{{$otherName}}) Observable{{$otherName}} {
	observable := func(observer {{$otherName}}ObserverFunc, scheduler Scheduler, unsubscriber Unsubscriber) {
		var wait struct {
			sync.Mutex
			Condition *sync.Cond
			Accum     int

			Add         func()
			Done        func()
			Cancel      func()
			WaitForZero func() bool
		}
		wait.Condition = sync.NewCond(&wait.Mutex)

		wait.Add = func() {
			wait.Lock()
			defer wait.Unlock()
			wait.Accum++
			wait.Condition.Broadcast()
		}

		wait.Done = func() {
			wait.Lock()
			defer wait.Unlock()
			wait.Accum--
			wait.Condition.Broadcast()
		}

		wait.Cancel = func() {
			wait.Lock()
			defer wait.Unlock()
			wait.Accum = -1
			wait.Condition.Broadcast()
		}

		wait.WaitForZero = func() bool {
			wait.Lock()
			defer wait.Unlock()
			for wait.Accum > 0 {
				wait.Condition.Wait()
			}
			return (wait.Accum == 0)
		}

		var lock sync.Mutex
		flatten := func(next {{$otherType}}, err error, completed bool) {
			lock.Lock()
			defer lock.Unlock()
			// Finally
			if err != nil || completed {
				wait.Done()
			}
			// IgnoreCompletion
			if !completed {
				observer(next, err, completed)
			}
		}

		unsubscriber.OnUnsubscribe(wait.Cancel)

		operator := func(next {{$type}}, err error, completed bool) {
			if err != nil || completed {
				if wait.WaitForZero() {
					observer(zero{{$otherName}}, err, err == nil)
				}
			} else {
				wait.Add()
				f(next)(flatten, scheduler, unsubscriber)
			}
		}

		o(operator, scheduler, unsubscriber)
	}
	return observable
}

{{end -}}
{{end -}}
